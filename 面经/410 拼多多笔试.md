###  A

模拟即可

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
const int N= 100010;
int n,a[N];
vector<int> v[N];
map<int,int> mp;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        v[a[i]].push_back(i);
        mp[a[i]]++;
    }
    vector<pair<int,int>> ans;
    for(auto x: mp){
        int f=1;
        int len=v[x.first].size();
        if(len==1){
            ans.push_back({x.first,0});
        }
        else{
            int c=v[x.first][1]-v[x.first][0];
            for(int i=2;i<len;i++){
                if(v[x.first][i]-v[x.first][i-1]!=c){
                    f=0;break;
                }
            }
            if(f){
                ans.push_back({x.first,c});
            }else continue;
        }
    }
    cout<<ans.size()<<endl;
    for(auto i:ans){
        cout<<i.first<<" "<<i.second<<endl;
    }
}
```

### B

简单BFS，处理一下细节

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
const int N= 100010;
int n,m,ans=-1;
string s[510];
struct node{
    int x,y,step;
};

int vis[510][510];
queue<node> q;
int dx[]={1,2,2,1,-1,-2,-2,-1};
int dy[]={-2,-1,1,2,2,1,-1,-2};
bool check(int x,int y){
    if(x>=0 && x<n && y>=0 && y<m && s[x][y]!='0' && !vis[x][y])
        return true;
    return false;
}
void bfs(){
    while(q.size()){
        int nowx=q.front().x;
        int nowy=q.front().y;
        int nows=q.front().step;
        if(s[nowx][nowy]=='T'){
            ans=nows;
            break;
        }
        q.pop();
        for(int i=0;i<8;i++){
            int nx=nowx+dx[i];
            int ny=nowy+dy[i];
            if(check(nx,ny) && (i==0||i==7) && s[nowx][nowy-1]!='0'){ 
                vis[nx][ny]=1;
                q.push({nx,ny,nows+1});
               
            }
            else if(check(nx,ny) && (i==1||i==2) && s[nowx+1][nowy]!='0'){
                vis[nx][ny]=1;
                q.push({nx,ny,nows+1});
            }
            else if(check(nx,ny) && (i==3||i==4) && s[nowx][nowy+1]!='0'){   
                vis[nx][ny]=1;
                q.push({nx,ny,nows+1});
            }
            else if(check(nx,ny) && (i==5||i==6) && s[nowx-1][nowy]!='0'){
                
                vis[nx][ny]=1;
                q.push({nx,ny,nows+1});
            }
        }
    }
}
int main(){
    int T;
    cin>>T;
    while(T--){
        ans=-1;
        while(q.size()) 
            q.pop();
        cin>>n>>m;
        for(int i=0;i<n;i++){
            cin>>s[i];
            for(int j=0;j<m;j++){
                vis[i][j]=0;
            }
        }
    
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(s[i][j]=='K'){
                    q.push({i,j,0});
                    vis[i][j]=1;
                    bfs();
                    goto here;
                }
            }
        }
        here:
        cout<<ans<<endl;
    }
}
```

### C

比赛的时候没想出来,直接上了一发暴力过66%……太菜了

思路：

$O(n)$维护每一个被占用的位置的下一个空位是什么即可，从给出的数组中即可简单的进行维护

### D

比赛的时候感觉像是DP，赛后讨论了一下朋友说贪心分情况讨论口胡了emmmm

比赛的时候没骗分，主要被B题搞了一下

蹲一个正解



### 反思：

简单的BFS都能被细节卡好久浪费时间，还是刷题量不够，因为被B搞了一下CD直接炸开来，实在是fw,努力刷题吧哎

